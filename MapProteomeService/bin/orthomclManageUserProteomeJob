#!/usr/bin/perl

use lib "$ENV{GUS_HOME}/lib/perl";
use File::Path;
use File::Copy;
use OrthoMCLShared::MapProteomeService::ProteomeJobMgr;
use Digest::MD5 qw(md5_hex);
use strict;

use constant DEBUG => 0;

=pod 

probe the state of orthomcl user's proteome analysis jobs

should be called by cron once every few minutes

** local dir structure **
controlDir/
  newJobs/
    92hty2k/
      info.txt
      proteome.fasta
  phase1/
    runningJobs/
      i83j89/
        info.txt
        input/
          controller.prop
          task.prop
        proteome.fasta
    doneJobs/
      43k8sl0/
        blastSimilarity.out
        info.txt
        input/
          controller.prop
          task.prop
        proteome.fasta
    failedJobs/
      a7bbe32/                (copied from runningJobs/)
  phase2/                     (same as phase1)


** cluster dir structure **
orthomclUserProteomeJobs/
  phase1/
    runningJobs/
      i83j89/
        info.txt
        input/
          controller.prop
          task.prop
        master/
          completedSubtasks.log
          failures/
          mainresult/
          running/
        i83j89.log
        processId
        proteome.fasta
    failedJobs/
      i83j89/        (copied from runningJobs/)
      i83j89.log     (copied from runningJobs/)
  phase2/            (same as phase1)


** info.txt file **
email=
fastaFileName=
submitted=
jobName=

=cut

usage() unless scalar(@ARGV) == 1;

my $configFile = $ARGV[0];

my $controlDir;
my $clusterServerDir;
my $dbSize;
my $fakeTaxonAbbrev = 'xxxx';

my $mgr = OrthoMCLShared::MapProteomeService::ProteomeJobMgr->new($configFile);

eval {
    $controlDir = $mgr->getConfig('controlDir');
    $clusterServerDir = $mgr->getConfig('clusterServerDir');

    warn "[DEBUG] using controlDir $controlDir\n" if DEBUG;
    warn "[DEBUG] using clusterServerDir $clusterServerDir\n" if DEBUG;

    mk_local_dirs();

    # phase 1 (self-self blast of user proteome)
    my ($doneJobs, $failedJobs) = checkRunningJobs('phase1');

    handleDoneJobs($doneJobs, 'phase1');

    handleFailedJobs($failedJobs, 'phase1');

    handleNewJobs("$controlDir/newJobs",
          "$controlDir/phase1/runningJobs",
          "$clusterServerDir/phase1/runningJobs",
          'phase1', $dbSize);

    # phase 2 (blast of user proteome against orthomcl proteins)

    my ($doneJobs, $failedJobs) = checkRunningJobs('phase2');

    handleDoneJobs($doneJobs, 'phase2');

    handleFailedJobs($failedJobs, 'phase2');

    handleNewJobs("$controlDir/phase1/doneJobs",
          "$controlDir/phase2/runningJobs",
          "$clusterServerDir/phase2/runningJobs",
          'phase2', $dbSize);

    # deliver results (process blast results, and deliver results to user)
    # for each phase 2 done job, process it, and delete when done
    deliverResults();
};

$mgr->error("error: '$@'") if $@;


sub findDbSize {
    my ($localRunningDir, $clusterRunningDir) = @_;

    my $clusterUserName = $mgr->getConfig('clusterUserName');
    my $rcfile = $mgr->getConfig('rcfile');
    my $clusterServer = $mgr->getConfig('clusterServer');
    my $dbFilePath = $mgr->getConfig('blastDbFilePath');

    $mgr->log("Counting proteins in $dbFilePath");

    # discover size of blast db (ie, count of orthomcl proteins)
    my $dbSizeOut = $mgr->runCmd(0, "ssh -2 $clusterUserName\@$clusterServer '/bin/bash -rcfile $rcfile -i -c \"grep \\> $dbFilePath |wc -l\"'");
    my @a = split(/\s/, $dbSizeOut);  # ignore output from login
    my $dbSize = $a[$#a];
    return $dbSize;
}

##################################################
# handle running jobs
##################################################

sub checkRunningJobs {
    my ($phase) = @_;

    warn "[DEBUG] checkRunningJobs() for phase $phase\n" if DEBUG;
    
    my $clusterUserName = $mgr->getConfig('clusterUserName');
    my $rcfile = $mgr->getConfig('rcfile');
    my $clusterServer = $mgr->getConfig('clusterServer');

    my $runningJobsDir = "$controlDir/$phase/runningJobs";
    mkpath($runningJobsDir);
    opendir(DIR, $runningJobsDir) || die "Can't open $phase runningJobs/ directory '$runningJobsDir'\n";
    my @runningJobs = readdir(DIR);
    closedir(DIR);

    my $doneJobs;
    my $failedJobs;
    foreach my $runningJob (@runningJobs) {
    next if $runningJob =~ /^\./;
    my $clusterRunningJobDir = "$clusterServerDir/$phase/runningJobs/$runningJob";
    if (!clusterTaskRunning($clusterRunningJobDir, $clusterUserName, $clusterServer)) {
      $mgr->log("Found $phase job that has finished running: $runningJob");
      my $logFile = "$clusterRunningJobDir/$runningJob.log";
      my $done = $mgr->runCmd(0, "ssh -2 $clusterUserName\@$clusterServer '/bin/bash -rcfile $rcfile -i -c \"if [ -a $logFile ]; then tail -1 $logFile; fi\"'");
      if ($done && $done =~ /Done/) {
        push(@$doneJobs, $runningJob);
      } else {
        push(@$failedJobs, $runningJob);
      }
    }
      }

    return ($doneJobs, $failedJobs);
}

sub clusterTaskRunning {
    my ($clusterJobDir, $clusterUserName, $clusterServer) = @_;

    warn "[DEBUG] clusterTaskRunning() for user $clusterUserName to server $clusterServer in job directory $clusterJobDir \n" if DEBUG;

    my $processId = `ssh -2 $clusterUserName\@$clusterServer 'if [ -a $clusterJobDir/processId ];then cat $clusterJobDir/processId; fi'`;

    chomp $processId;

    my $status = 0;
    if ($processId) {
      system("ssh -2 $clusterUserName\@$clusterServer 'ps -p $processId > /dev/null'");
      $status = $? >> 8;
      $status = !$status;
    }
    return $status;
}


##################################################
# handle completed jobs
##################################################
sub handleDoneJobs {
    my ($doneJobs, $phase) = @_;

    warn "[DEBUG] handleDoneJobs() for $doneJobs in phase $phase\n" if DEBUG;

    my $clusterUserName = $mgr->getConfig('clusterUserName');
    my $rcfile = $mgr->getConfig('rcfile');
    my $clusterServer = $mgr->getConfig('clusterServer');
    my $localRunningDir = "$controlDir/$phase/runningJobs";
    my $localDoneDir = "$controlDir/$phase/doneJobs";

    foreach my $doneJob (@$doneJobs) {

      $mgr->log("Handling done $phase cluster job: $doneJob");
      mkpath($localDoneDir);
      move("$localRunningDir/$doneJob", "$localDoneDir/$doneJob");

      # zip blast result
      $mgr->log("  gzipping blast result on cluster");
      my $clusterRunningJobDir = "$clusterServerDir/$phase/runningJobs/$doneJob";
      $mgr->runCmd(0, "ssh -2 $clusterUserName\@$clusterServer '/bin/bash -rcfile $rcfile -i -c \"gzip $clusterRunningJobDir/master/mainresult/blastSimilarity.out\"'");

      # copy result from cluster
      $mgr->log("  copying from cluster");
      $mgr->getCluster()->copyFrom("$clusterRunningJobDir/master/mainresult", 'blastSimilarity.out.gz', "$localDoneDir/$doneJob");
      move("$localDoneDir/$doneJob/blastSimilarity.out.gz", "$localDoneDir/$doneJob/${phase}BlastSimilarity.out.gz");


      # clean up cluster dir
      $mgr->log("  cleaning up cluster job dir");
      $mgr->runCmd(0, "ssh -2 $clusterUserName\@$clusterServer '/bin/bash -rcfile $rcfile -i -c \"rm -rf $clusterRunningJobDir\"'");

    }
}

sub deliverResults {

    my $phase2DoneDir = "$controlDir/phase2/doneJobs";
    opendir(DIR, $phase2DoneDir) || die "Can't open phase2 doneJobs/ directory '$phase2DoneDir'\n";
    my @donePhase2Jobs = readdir(DIR);
    closedir(DIR);

    mkpath("$controlDir/phase2/doneJobsDebug");

    foreach my $phase2DoneJob (@donePhase2Jobs) {
      next if $phase2DoneJob =~ /^\./;
      $mgr->log("Final processing for $phase2DoneJob");
      deliverResult("$controlDir/phase2/doneJobs/$phase2DoneJob", $phase2DoneJob);
      $mgr->log("  cleaning up local phase2 job dir");

      # move to archive for debugging
      rename("$controlDir/phase2/doneJobs/$phase2DoneJob",
      "$controlDir/phase2/doneJobsDebug/$phase2DoneJob");

      # remove from archive unless debugging
      rmtree("$controlDir/phase2/doneJobsDebug/$phase2DoneJob");
    }
}

sub deliverResult {
    my ($donePhase2JobDir, $jobId) = @_;

    my $groupsFile = $mgr->getConfig('groupsFile');
    my $mclBin = $mgr->getConfig('mclBin');
    my $resultDir = $mgr->getConfig('resultDir');

    # map to groups
    $mgr->log("  mapping to groups");
    mkpath("$donePhase2JobDir/orthomclResult");
    my $cmd = "orthomclMapProteomeToGroups $donePhase2JobDir/phase1BlastSimilarity.out.gz $donePhase2JobDir/phase2BlastSimilarity.out.gz $groupsFile $fakeTaxonAbbrev $donePhase2JobDir/orthomclResult $mclBin $donePhase2JobDir/log";
    $mgr->log("  $cmd");
    $mgr->runCmd(0, $cmd);
    open(L, "$donePhase2JobDir/log");
    while(<L>) {print STDERR $_;}
    close(L);

    # make README
    my $readmeFile = "$donePhase2JobDir/orthomclResult/README";
    open(R, ">$readmeFile") || die "Can't open readme file '$readmeFile' for writing";
    print R readme();
    close(R);

    # zip result
    copy("$donePhase2JobDir/info.txt", "$donePhase2JobDir/orthomclResult");
    $mgr->log("  zipping");
    $mgr->runCmd(0, "zip -rj $donePhase2JobDir/orthomclResult $donePhase2JobDir/orthomclResult");

    # move zipped result to delivery dir
    mkpath($resultDir);
    $mgr->log("  moving final result to $resultDir/orthomclResult-$jobId.zip");
    move("$donePhase2JobDir/orthomclResult.zip", "$resultDir/orthomclResult-$jobId.zip");

    # email result
    $mgr->log("  mailing notification");
    mailResult("$donePhase2JobDir/info.txt", $jobId);
}


##################################################
# handle new jobs
##################################################
sub handleNewJobs {
    my ($newJobsDir, $localRunningDir, $clusterRunningDir, $phase) = @_;

    warn "[DEBUG] handleNewJobs() from newJobsDir $newJobsDir, localRunningDir $localRunningDir, clusterRunningDir $clusterRunningDir for phase $phase\n" if DEBUG;

    # find all subdirs 
    opendir(DIR, $newJobsDir) || die "Can't open $phase new jobs directory '$newJobsDir'\n";
    my @newJobs = readdir(DIR);
    closedir(DIR);

    foreach my $newJob (@newJobs) {
    next if $newJob =~ /^\./;
    $mgr->log("New $phase job: $newJob");

    my $clusterUserName = $mgr->getConfig('clusterUserName');
    my $rcfile = $mgr->getConfig('rcfile');
    my $clusterServer = $mgr->getConfig('clusterServer');
    my $newJobDir = "$newJobsDir/$newJob";
    my $runningJobDir = "$localRunningDir/$newJob";
    my $localInputDir = "$runningJobDir/input";
    my $masterDir = "$runningJobDir/master";
    my $clusterRunningJobDir = "$clusterRunningDir/$newJob";
    my $clusterInputDir = "$clusterRunningJobDir/input";

    correctProteomeFile("$newJobDir/orig_proteome.fasta", "$newJobDir/proteome.fasta");

    if ($phase eq 'phase1') {
        my $validateResultError = validateProteomeFile($newJobDir, "proteome.fasta");
        my $formatResultError = formatProteomeFile($newJobDir, "proteome.fasta") if ( ! $validateResultError);

        if (! $validateResultError && ! $formatResultError) {
            mailSubmit("$newJobDir/info.txt", $newJob);
        } else {
            $mgr->log("  invalid fasta");
            my $reason = $validateResultError . "\n" . $formatResultError;
            mailInvalidFasta("$newJobDir/info.txt", $newJob, $reason);
            rmtree($newJobDir);
            next;
        }
    }

    # discover size of orthomcl blast database
    $dbSize = findDbSize() unless $dbSize;

        # move new job dir to running/
    mkpath($runningJobDir);
    move("$newJobsDir/$newJob", $runningJobDir);

    # move proteome file to localInputDir
    mkpath($localInputDir);
    #$move("$runningJobDir/proteome.fasta", $localInputDir);

    my $dbFilePath =  ($phase eq 'phase1')?
      "$clusterRunningJobDir/proteome.fasta" :
        $mgr->getConfig('blastDbFilePath');

    # build input/ dir
    makeTaskFile($localInputDir, $clusterInputDir, $clusterRunningJobDir, $dbFilePath, $dbSize);
    makeControllerFile($localInputDir, $clusterInputDir);

    # mirror job to cluster
    $mgr->log("Mirroring $newJob/ to cluster");
    $mgr->getCluster()->copyTo($localRunningDir, $newJob, $clusterRunningDir);

#     if ($phase eq 'phase1') {
# 
#         # formatdb does not return proper exit code.  generate one by
#         # grepping its log for 'Error'
#         my $blastBinDir = $mgr->getConfig('blastBinDir');
#         my $formatdbLog = "$clusterRunningJobDir/formatdb.log";
#         my $cmd = "$blastBinDir/formatdb -i $dbFilePath -l $formatdbLog -p T;grep ERROR $formatdbLog; if [ \\\$? -eq 0 ]; then false; else true; fi";
# 
#         $mgr->log("Formatting proteome.fasta for self-self blast");
#         $mgr->runCmd(0, "ssh -2 $clusterUserName\@$clusterServer '/bin/bash -rcfile $rcfile -i -c \"$cmd\"'");
#     }

    # start cluster job
    startJob("$clusterRunningJobDir", $newJob);
    }

}

# format proteome file with NCBI formatdb and return empty string if successful, error message otherwise
sub formatProteomeFile {
    my ($newJobDir, $proteomeFilename) = @_;
    my $proteomeFilePath = "$newJobDir/$proteomeFilename";
    
    my $formatdbBinDir = $mgr->getConfig('formatdbBinDir');
    my $formatdbLog = "$newJobDir/formatdb.log";

    # (sfischer's original code; exit code seems to be correct in formatdb 2.2.25, so dropping this extra hoop)
    # formatdb does not return proper exit code.  generate one by
    # grepping its log for 'Error'
    # my $cmd = "$formatdbBinDir/formatdb -i $proteomeFilePath -l $formatdbLog -p T;grep ERROR $formatdbLog; if [ \$? -eq 0 ]; then false; else true; fi";

    $mgr->log("Formatting proteome.fasta for self-self blast");
    my $cmd = "$formatdbBinDir/formatdb -i $proteomeFilePath -l $formatdbLog -p T";
    warn "[DEBUG] $cmd" if DEBUG;
    my $status = system($cmd);
    $mgr->log("Failed running: \n$cmd") if ($status);
    my $error = "";
    if ($status) {
        $error = "formatdb failed with\n";
        $error .= `egrep 'WARNING|FATAL' $formatdbLog`;
    }
    return $error;
}

# basic check for fasta file format and sequence # and length limits
sub validateProteomeFile {
    my ($newJobDir, $proteomeFilename) = @_;
    my $proteomeFilePath = "$newJobDir/$proteomeFilename";
    my $length;
    my $seqCount;
    die "Fasta file '$proteomeFilePath' does not exist" unless -e $proteomeFilePath;
    system("dos2unix $proteomeFilePath");
    open(P, $proteomeFilePath) || die "Can't open fasta file '$proteomeFilePath'\n";
    while(<P>) {
        $length += length($_);
        $seqCount += 1 if /^\>\S+/;
    }
    close(P);
    my $error;
    if ($seqCount && $seqCount <= 100000 && $length <= $seqCount * 5000) {
        $error = ""
    } else {
        $error = "The file must be in FASTA format and contain no more than 100,000 protein sequences."
    }
    return $error;
}

sub correctProteomeFile {
    my ($orig_proteomeFile, $proteomeFile) = @_;

    open(O, $orig_proteomeFile) || die "can't open file $orig_proteomeFile\n";
    open(N, ">$proteomeFile") || die "can't open file $proteomeFile for writing\n";
    while (<O>) {
        s/\t/ /g;  # lose tab chars.  formatdb fails on them.
        s/\>/\>$fakeTaxonAbbrev\|/ if (/\>/);
        print N $_;
    }
    close(O);
    close(N);
}

sub makeTaskFile {
    my ($localInputDir, $clusterInputDir, $clusterRunningJobDir, $dbFilePath, $dbSize) = @_;
      open(F, ">$localInputDir/task.prop") || die "Can't open task prop file '$localInputDir/task.prop' for writing\n";

    my $blastBinDir = $mgr->getConfig('blastBinDir');
    my $clusterUserName = $mgr->getConfig('clusterUserName');
    my $rcfile = $mgr->getConfig('rcfile');
    my $clusterServer = $mgr->getConfig('clusterServer');

    print F
"blastBinDir=$blastBinDir
dbFilePath=$dbFilePath
inputFilePath=$clusterRunningJobDir/proteome.fasta
dbType=p
regex='(\\S+)'
blastProgram=blastp
blastParamsFile=blastParams
blastVendor=ncbi
printSimSeqsFile=yes
";
    close(F);

    # make blastParams file
    my $blastArgs = $mgr->getConfig('blastArgs');
    die "error: do not include -z arg in blastArgs property.  it is discovered dynamically\n" if $blastArgs =~ /z/;
    open(F, ">$localInputDir/blastParams") || die "Can't open blast params file '$localInputDir/blastParams' for writing\n";;
    print F "$blastArgs -z $dbSize\n";
    close(F);
}

sub makeControllerFile {
    my ($localInputDir, $clusterInputDir) = @_;
  my ($self, $taskInputDir, $slotsPerNode, $taskSize, $taskClass) = @_;

  my $nodePath = $mgr->getConfig('nodePath');
  my $slotsPerNode = $mgr->getConfig('slotsPerNode');
  my $nodeClass = $mgr->getConfig('nodeClass');
  my $taskSize = $mgr->getConfig('taskSize');
  my $taskClass = $mgr->getConfig('taskClass');
  my $nodeClass = $mgr->getConfig('nodeClass');

  my $clusterMasterDir = $clusterInputDir;
  $clusterMasterDir =~ s/input/master/;
  $nodeClass = 'DJob::DistribJob::BprocNode' unless $nodeClass;

  # print out the file
  my $controllerPropFile = "$localInputDir/controller.prop";
  open(F, ">$controllerPropFile")
      || $self->error("Can't open controller prop file '$controllerPropFile' for writing");
  print F 
"masterdir=$clusterMasterDir
inputdir=$clusterInputDir
nodedir=$nodePath
slotspernode=$slotsPerNode
subtasksize=$taskSize
taskclass=$taskClass
nodeclass=$nodeClass
restart=no
";
    close(F);
}

sub startJob {
    my ($clusterJobDir, $jobId) = @_;

    warn "[DEBUG] startJob() for jobId $jobId in clusterJobDir $clusterJobDir\n" if DEBUG;

    my $clusterUserName = $mgr->getConfig('clusterUserName');
    my $rcfile = $mgr->getConfig('rcfile');
    my $clusterServer = $mgr->getConfig('clusterServer');
    my $numNodes = $mgr->getConfig('numNodes');
    my $clusterQueue = $mgr->getConfig('clusterQueue');
    my $ppn = $mgr->getConfig('ppn');

    $mgr->log("Starting job on cluster in $clusterJobDir");
    $mgr->runClusterTask($clusterUserName, $rcfile, $clusterServer, "$clusterJobDir/processId", "$clusterJobDir/$jobId.log", "$clusterJobDir/input/controller.prop", $numNodes, 14400, $clusterQueue, $ppn);
}


##################################################
# handle failed jobs
##################################################
sub handleFailedJobs {
    my ($failedJobs, $phase) = @_;

    warn "[DEBUG] handleFailedJobs() for $failedJobs in phase $phase\n" if DEBUG;

    my $clusterUserName = $mgr->getConfig('clusterUserName');
    my $rcfile = $mgr->getConfig('rcfile');
    my $clusterServer = $mgr->getConfig('clusterServer');
    my $localRunningDir = "$controlDir/$phase/runningJobs";
    my $localFailedDir = "$controlDir/$phase/failedJobs";

    foreach my $failedJob (@$failedJobs) {

      mailServerError("$localRunningDir/$failedJob/info.txt", $failedJob);
      $mgr->log("Handling $phase failed job: $failedJob");
      $mgr->log("  moving local job to $phase failed dir");
      mkpath("$localFailedDir");
      move("$localRunningDir/$failedJob", "$localFailedDir/$failedJob");

      # clean up cluster dir
      $mgr->log("  moving cluster job to $phase cluster failed dir");
      my $clusterRunningJobDir = "$clusterServerDir/$phase/runningJobs/$failedJob";
      my $clusterFailedJobDir = "$clusterServerDir/$phase/failedJobs/$failedJob";
      
      mailServerErrorToAdmin("$localFailedDir/$failedJob/info.txt", $failedJob, "$localFailedDir/$failedJob", $clusterFailedJobDir);

      $mgr->runCmd(0, "ssh -2 $clusterUserName\@$clusterServer '/bin/bash -rcfile $rcfile -i -c \"mv $clusterRunningJobDir $clusterFailedJobDir\"'");
    }
}

sub mailSubmit {
  my ($infoFile, $jobId) = @_;

  my $msg = "
has been submitted.  You will get a mail when it is done (4 to 12 hours).
";
  mailJob($infoFile, $jobId, "OrthoMCL Job - submitted", $msg);
}

sub mailServerError {
  my ($infoFile, $jobId) = @_;

  my $msg = "
has failed because of a server error.  Please try again, or respond to this mail to report the problem.
";
  mailJob($infoFile, $jobId, "OrthoMCL Job - server error", $msg);
}

sub mailServerErrorToAdmin {
  my ($infoFile, $jobId, $localFailedJobPath, $remoteFailedJobPath) = @_;
  my $cluster = $mgr->getConfig('clusterServer');
  my $local = `hostname`;
  my $msg = "See failed job at $local:$localFailedJobPath and\n$cluster:$remoteFailedJobPath";
  mailAdmin($infoFile, $jobId, "OrthoMCL Job - server error", $msg);
}

sub mailInvalidFasta {
  my ($infoFile, $jobId, $reason) = @_;

  my $msg = "
has an invalid sequence file.
$reason
Please resubmit with a valid file.
";
  mailJob($infoFile, $jobId, "OrthoMCL Job - invalid file", $msg);
}

sub mailResult {
  my ($infoFile, $jobId) = @_;

  my $baseUrl = $mgr->getConfig('resultBaseUrl');
  my $link = "$baseUrl$jobId";

  my $msg = "
is complete.  The results are now available at:
  $link

They will be available for 48 hours.
";
  mailJob($infoFile, $jobId, "OrthoMCL Job - done", $msg);
}

sub mailAdmin {
  my ($infoFile, $jobId, $subject, $message) = @_;

  my $adminEmail = $mgr->getConfig('adminEmail');

  open(I, $infoFile) || die "Can't open info file '$infoFile'\n";
  my $info;
  while (<I>) {
    chomp;
    my($key, $value) = split(/\=/);
    $info->{$key} = $value;
  }
  close(I);
  $info->{email} =~ /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i or die "Illegal email address: '$info->{email}'\n";

  my @a = split(/\@/, $info->{email});
  my $login = shift(@a);

  my $body = "
Server Error on OrthoMCL job:
  ID:         $jobId
  Name:       $info->{jobName}
  Fasta file: $info->{fastaFileName}
  Submitted:  $info->{submitted} (EST)
$message
";

  open(SENDMAIL, "|/usr/sbin/sendmail -t") or die "Cannot open sendmail: $!\n";
  print SENDMAIL "Subject: $subject\n";
  print SENDMAIL "To: $adminEmail\n";
  print SENDMAIL "From: help\@orthomcl.org\n";
  print SENDMAIL "Content-type: text/plain\n\n";
  print SENDMAIL $body;
  close(SENDMAIL);
}

sub mailJob {
  my ($infoFile, $jobId, $subject, $message) = @_;

  open(I, $infoFile) || die "Can't open info file '$infoFile'\n";
  my $info;
  while (<I>) {
    chomp;
    my($key, $value) = split(/\=/);
    $info->{$key} = $value;
  }
  close(I);
  $info->{email} =~ /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i or die "Illegal email address: '$info->{email}'\n";

  my @a = split(/\@/, $info->{email});
  my $login = shift(@a);

  my $body = "
Hello $login,

Your OrthoMCL job:
  ID:         $jobId
  Name:       $info->{jobName}
  Fasta file: $info->{fastaFileName}
  Submitted:  $info->{submitted} (EST)
$message
Thank you for using OrthoMCL,
The OrthoMCL Team
";

  open(SENDMAIL, "|/usr/sbin/sendmail -t") or die "Cannot open sendmail: $!\n";
  print SENDMAIL "Subject: $subject\n";
  print SENDMAIL "To: $info->{email}\n";
  print SENDMAIL "From: help\@orthomcl.org\n";
  print SENDMAIL "Content-type: text/plain\n\n";
  print SENDMAIL $body;
  close(SENDMAIL);
}

sub mk_local_dirs {
    qx(mkdir -p $controlDir/{results,newJobs});
    qx(mkdir -p $controlDir/phase1/{runningJobs,doneJobs});
    qx(mkdir -p $controlDir/phase2/{runningJobs,doneJobs});
    qx(chmod 1777 $controlDir/newJobs);
}

sub usage {
  print STDERR "

usage:
   orthomclManageUserProteomeJob config_file

** config file **
blastDbFilePath= (blast database file)
groupsFile=           (orthomcl groups to map blast results to)
controlDir=           (local dir to control this job)
clusterUserName=      (login to use to get into cluster server)
rcfile=               (rcfile to prepare bash environment)
clusterServer=        (name of machine)
clusterServerDir=     (dir there to put our stuff in)
clusterQueue=         (queue to use)
numNodes=             (num of nodes to request)
slotsPerNode=         (slots per each node)
ppn=                  (parallelization)
nodePath=             (???)
nodeClass=            (perl class to represent this type of node)
taskSize=             (number of seqs to process in one batch)
taskClass=            (perl class to manage that processing)
blastArgs=            (arguments for blast)
blastBinDir=          (location of blast executable)
mclBin=               (location of mcl executable)
resultDir             (dir to write result zip file to)
resultBaseUrl=          (URL to append job key to)
";

sub readme {
    return "
Output: A .zip file containing the following text files:

orthomclResults/
  orthologGroups    a map between your proteins and OrthoMCL groups. Tab 
                    delimited.  Columns: your_protein, orthomcl_group, 
                    seq_id_of_best_hit, evalue_mantissa, evalue_exponent,
                    percent_identity, percent_match.
  paralogPairs      reciprocal best hits among those proteins in your genome
                    that were not mapped to OrthoMCL groups, as described
                    below in the Algorithms section.
  paralogGroups     the proteins in paralogPairs clustered into groups by
                    the mcl program, as described below in the Algorithms
                    section.



Algorithm

Please refer to the OrthoMCL Algorithm Document ()for details about how OrthoMCL-DB is created.

    * BLASTP of your proteins against self and against OrthoMCL proteins. Cutoff of e-5, and 50% match.
    * For proteins that have an above-threshold match: assign the group from the best matching OrthoMCL protein. If the best OrthoMCL protein does not have a group, assign NO_GROUP.
    * For remaining proteins: use the InParalog algorithm described in the OrthoMCL Algorithm Document to find potential paralog pairs.
    * Submit those pairs to the MCL program (see the OrthoMCL Algorithm Document). 
";
}

exit(1);

}


